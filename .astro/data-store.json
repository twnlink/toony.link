[["Map",1,2,7,8],"meta::meta",["Map",3,4,5,6],"astro-version","5.4.1","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[]},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":\"shiki\",\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"responsiveImages\":false,\"serializeConfig\":false},\"legacy\":{\"collections\":false}}","blog",["Map",9,10,25,26,41,42],"obligatory-initial-post",{"id":9,"data":11,"body":14,"filePath":15,"digest":16,"rendered":17,"legacyId":24},{"title":12,"timestamp":13},"obligatory initial blog post",1740852073,"every blog has an initial \"test\" post that basically translates to \"i do not have interesting content to put here\", and also \"my SSG will break if i don't have at least 1 blog post\". this post exists due to the latter.","src/content/blog/obligatory initial post.md","38a99cd823e8485d",{"html":18,"metadata":19},"\u003Cp>every blog has an initial “test” post that basically translates to “i do not have interesting content to put here”, and also “my SSG will break if i don’t have at least 1 blog post”. this post exists due to the latter.\u003C/p>",{"headings":20,"localImagePaths":21,"remoteImagePaths":22,"frontmatter":11,"imagePaths":23},[],[],[],[],"obligatory initial post.md","an-exercise-in-futility",{"id":25,"data":27,"body":30,"filePath":31,"digest":32,"rendered":33,"legacyId":40},{"title":28,"timestamp":29},"an exercise in futility",1740861851,"\u003Csmall>\nthis is a mirror of cumcord.com's \"AN EXERCISE IN FUTILITY\" but with markdown.\n\nyou can read the original [here](https://web.archive.org/web/20221118170800/https://cumcord.com/an-exercise-in-futility).\n\u003C/small>\n\nCumcord has been discontinued after more than a year of continuous development.\n\nI made Cumcord when client modding was stuck between BetterDiscord, and Powercord. More than a year later, we even survived through the death of Powercord.\n\n\nA year ago when I created Cumcord I just wanted to make something lighter, simpler, and easier to develop for than other client mods, so I created a new standard for plugin development. \n\n![XKCD standards comic](https://imgs.xkcd.com/comics/standards.png)\n\nI've gotten tons of reports that I succeeded in my goal of making plugin development easier, so it may come as a surprise that Cumcord's development has ceased. \n\nDiscord recently pushed an update that swaps out [Babel](https://web.archive.org/web/20221118170800/https://babel.dev/) for [SWC](https://web.archive.org/web/20221118170800/https://swc.rs/) in their frontend build pipeline, which enabled mangling on certain webpack modules, and stripped displayNames from React components. \n\n...including Cumcord.\n\nUpon noticing this happened, BetterDiscord and Replugged were fixed, albeit with every plugin broken. They both announced they'd begun working on rewrites. GooseMod was discontinued. \n\nEvery person who was willing to maintain Cumcord in our community discussed the changes hours before they were pushed to stable.\n\nWe came to the conclusion that while we could do the same thing that BetterDiscord and Replugged did and rewrite the mod, it wasn't worth it.\n\nCumcord was built on simple DX. The change Discord introduced made one of the core, simple to understand principals of client modding significantly more complex, despite how small the change was. If we rewrote Cumcord, our code would become disorganized, modules would be found through inconsistent methods, and React components would be even harder to debug.\n\nThen I realized something that should've been obvious. Client modding is not sustainable.\n\nDiscord client modding for the longest time has been incredibly tightly coupled to Discord's code and assumptions that Discord does not care about improving their build pipeline.\n\nWe complain about client mods breaking a lot, but we've engineered them for convenience over sustainability.\n\nDiscord at any point could ditch Webpack and move to Vite. Discord at any point could deprecate React components we heavily use. Discord at any point could remove any of the 3 state management libraries included in the client.\n\nRewriting Cumcord and building it on the same principals we did before would be just as unsustainable as it was before, and it'd be even harder to develop for. It would be a shell of it's former self.\n\nIf we wanted to keep writing Discord mods we'd have to build something that isn't Cumcord.\n\n...so we are.\n![shelter logo](https://raw.githubusercontent.com/uwu/shelter/main/packages/shelter-assets/svg/banner.svg)\nshelter is our new experimental Discord mod that tries to think outside of the box. We're trying things that the majority of the client modding community have ignored in favor of convenience. shelter is built to be sustainable.\n\nDiscord has engineered their client on Facebook's Flux state management paradigm. This means that the app's global state is decoupled from their React components, and also accessible in one convenient place. Other mods do use Flux, but shelter is built on it. It's the core of Discord's desktop client, and it's the least likely to change.\n\nOther client mods rely heavily on Discord's React components. shelter aims to avoid reliance on too much Discord code, so we're creating our own components that recreate Discord's.\n\nDiscord is built on React. shelter will be built on Solid.js.\n\nAll of these small details add up, and will hopefully make shelter more sustainable than the majority of other client mods. \n\nYou can follow shelter's development in the [uwu.network Discord server](https://web.archive.org/web/20221118170800/https://discord.gg/FhHQQrVs7U), which will also be the home for other projects from Cumcord's development team, [uwu.network](https://web.archive.org/web/20221118170800/https://uwu.network/).\n\nCumcord was an important part of the Discord modding community (we were the 4th most popular mod for the longest time, very cool!) and it helped me meet a lot of people I care about. Those people are still around, and I'd like to thank them for being here. I'd also like to thank anyone who supported Cumcord, you mean quite a bit to me. \n\nAll of this is to say that Cumcord is dead, and that's okay. It wasn't built to last.","src/content/blog/an exercise in futility.md","cf464d35876336b6",{"html":34,"metadata":35},"\u003Csmall>\nthis is a mirror of cumcord.com's \"AN EXERCISE IN FUTILITY\" but with markdown.\n\u003C/small>\u003Cp>\u003Csmall>you can read the original \u003Ca href=\"https://web.archive.org/web/20221118170800/https://cumcord.com/an-exercise-in-futility\">here\u003C/a>.\n\u003C/small>\u003C/p>\n\u003Cp>Cumcord has been discontinued after more than a year of continuous development.\u003C/p>\n\u003Cp>I made Cumcord when client modding was stuck between BetterDiscord, and Powercord. More than a year later, we even survived through the death of Powercord.\u003C/p>\n\u003Cp>A year ago when I created Cumcord I just wanted to make something lighter, simpler, and easier to develop for than other client mods, so I created a new standard for plugin development.\u003C/p>\n\u003Cp>\u003Cimg src=\"https://imgs.xkcd.com/comics/standards.png\" alt=\"XKCD standards comic\">\u003C/p>\n\u003Cp>I’ve gotten tons of reports that I succeeded in my goal of making plugin development easier, so it may come as a surprise that Cumcord’s development has ceased.\u003C/p>\n\u003Cp>Discord recently pushed an update that swaps out \u003Ca href=\"https://web.archive.org/web/20221118170800/https://babel.dev/\">Babel\u003C/a> for \u003Ca href=\"https://web.archive.org/web/20221118170800/https://swc.rs/\">SWC\u003C/a> in their frontend build pipeline, which enabled mangling on certain webpack modules, and stripped displayNames from React components.\u003C/p>\n\u003Cp>…including Cumcord.\u003C/p>\n\u003Cp>Upon noticing this happened, BetterDiscord and Replugged were fixed, albeit with every plugin broken. They both announced they’d begun working on rewrites. GooseMod was discontinued.\u003C/p>\n\u003Cp>Every person who was willing to maintain Cumcord in our community discussed the changes hours before they were pushed to stable.\u003C/p>\n\u003Cp>We came to the conclusion that while we could do the same thing that BetterDiscord and Replugged did and rewrite the mod, it wasn’t worth it.\u003C/p>\n\u003Cp>Cumcord was built on simple DX. The change Discord introduced made one of the core, simple to understand principals of client modding significantly more complex, despite how small the change was. If we rewrote Cumcord, our code would become disorganized, modules would be found through inconsistent methods, and React components would be even harder to debug.\u003C/p>\n\u003Cp>Then I realized something that should’ve been obvious. Client modding is not sustainable.\u003C/p>\n\u003Cp>Discord client modding for the longest time has been incredibly tightly coupled to Discord’s code and assumptions that Discord does not care about improving their build pipeline.\u003C/p>\n\u003Cp>We complain about client mods breaking a lot, but we’ve engineered them for convenience over sustainability.\u003C/p>\n\u003Cp>Discord at any point could ditch Webpack and move to Vite. Discord at any point could deprecate React components we heavily use. Discord at any point could remove any of the 3 state management libraries included in the client.\u003C/p>\n\u003Cp>Rewriting Cumcord and building it on the same principals we did before would be just as unsustainable as it was before, and it’d be even harder to develop for. It would be a shell of it’s former self.\u003C/p>\n\u003Cp>If we wanted to keep writing Discord mods we’d have to build something that isn’t Cumcord.\u003C/p>\n\u003Cp>…so we are.\n\u003Cimg src=\"https://raw.githubusercontent.com/uwu/shelter/main/packages/shelter-assets/svg/banner.svg\" alt=\"shelter logo\">\nshelter is our new experimental Discord mod that tries to think outside of the box. We’re trying things that the majority of the client modding community have ignored in favor of convenience. shelter is built to be sustainable.\u003C/p>\n\u003Cp>Discord has engineered their client on Facebook’s Flux state management paradigm. This means that the app’s global state is decoupled from their React components, and also accessible in one convenient place. Other mods do use Flux, but shelter is built on it. It’s the core of Discord’s desktop client, and it’s the least likely to change.\u003C/p>\n\u003Cp>Other client mods rely heavily on Discord’s React components. shelter aims to avoid reliance on too much Discord code, so we’re creating our own components that recreate Discord’s.\u003C/p>\n\u003Cp>Discord is built on React. shelter will be built on Solid.js.\u003C/p>\n\u003Cp>All of these small details add up, and will hopefully make shelter more sustainable than the majority of other client mods.\u003C/p>\n\u003Cp>You can follow shelter’s development in the \u003Ca href=\"https://web.archive.org/web/20221118170800/https://discord.gg/FhHQQrVs7U\">uwu.network Discord server\u003C/a>, which will also be the home for other projects from Cumcord’s development team, \u003Ca href=\"https://web.archive.org/web/20221118170800/https://uwu.network/\">uwu.network\u003C/a>.\u003C/p>\n\u003Cp>Cumcord was an important part of the Discord modding community (we were the 4th most popular mod for the longest time, very cool!) and it helped me meet a lot of people I care about. Those people are still around, and I’d like to thank them for being here. I’d also like to thank anyone who supported Cumcord, you mean quite a bit to me.\u003C/p>\n\u003Cp>All of this is to say that Cumcord is dead, and that’s okay. It wasn’t built to last.\u003C/p>",{"headings":36,"localImagePaths":37,"remoteImagePaths":38,"frontmatter":27,"imagePaths":39},[],[],[],[],"an exercise in futility.md","stealing-intellectual-property",{"id":41,"data":43,"body":46,"filePath":47,"digest":48,"rendered":49,"legacyId":75},{"title":44,"timestamp":45},"how to steal intellectual property you don't own",1740863435,"Recently while scrolling through Twitter I saw a post linking to a really high quality 3D model on [VRoid Hub](https://hub.vroid.com).\n\nWhen you visit any VRoid Hub page, you'll notice a large preview of the model that you can interact with, even if downloads are disabled.\n\nThis got me thinking: what's stopping someone from simply replicating the network request the website uses to fetch the contents of these private models?\n\nAs it turns out? *A lot*.\n\n## what you'd normally do\nThe first thing I did was attempt to pull up the network tab, which yielded model data basically immediately:\n\u003Cimg src=\"/blog-images/intp-network.png\" width=\"700\">\n\nI had no idea what a VRM was, but upon Googling it appeared to just be a GLB file with extensions.\n\nSo, I threw the model data into a GLB viewer. It couldn't read it.\n\n## what vroid hub actually does\nBy using the Chrome debugger and stepping through the site's code, I very quickly discovered that the obfuscated VRM file was encrypted with data that was present in the file itself.\n\nEach encrypted VRM is split up into 4 segments, separated by bytes:\n- 0 through 16 are an `iv` for decryption\n- 16 through 48 is the decryption key itself\n- 48 through 52 is the size of the decompressed version of the file\n\nBy just throwing these into crypto.subtle's decrypt function using `AES-CBC`, you can yield a perfectly good, albeit, compressed VRM file.\n\nThe compression VRoid Hub uses is ZSTD, which is very easy to decompress.\n\nAfter decrypting using the steps above, you'd think that you'd have a fully-functional model, right?\n\n\u003Cimg src=\"/blog-images/intp-clearly-not-hatsune-miku.png\" width=\"500\">\n\nIf this looks like the world-renowned artist Hatsune Miku to you, feel free to close the article here.\n\n## okay wtf\nWhile discussing this with a friend, they mentioned a tool used by the VRChat community called [KannaProtecc](https://github.com/PlagueVRC/AntiRip). KannaProtecc randomizes the vertices of a model’s mesh and uses a shader to correct their positions in real-time during gameplay. This sounded suspiciously similar to what I was seeing.\n\nInspecting the model further, I noticed a pretty striking GLB extension mentioned nowhere on the internet: `PIXIV_vroid_hub_preview_mesh`.\n\nSearching through the VRoid Hub website source code for this string, you'll very quickly find an  implementation of this extension with references to a \"seedmap\".\n\n\u003Cimg src=\"/blog-images/intp-vroidhub-ext.png\">\n\nI extracted the relevant code and started analyzing it.\n\n## how does this shit work\nThe obfuscation process uses a pseudo-random number generator (PRNG) that produces consistent results when given the same initial seed. The seed is derived by using a \"timestamp\" property on the `PIXIV_vroid_hub_preview_mesh` extension and mapping it to a \"seedmap\", which is generated from running a sha1 hash over the model's URL. The extension generates a 256x256 \"meta texture\" using this PRNG. This texture contains the data needed to decode each vertex.\n\nThe extension then processes each node in the model’s scene, adding a meta attribute to every primitive. This attribute is calculated by running the PRNG for each vertex, generating a number between 0 and 256, normalizing it to a range of 0 to 1, and storing it in an array. Since the PRNG is deterministic, each vertex gets the same `meta` attribute every time the extension runs.\n\nA shader is applied to sample the meta texture using the meta attribute. It scales the RGB values of the sample by 16.0 and subtracts the result from the vertex position. The direction of the displacement depends on the sign of the transformed vertex components, causing each vertex to shift toward or away from the origin based on the texture data.\n\nThis is word salad, but this is also my first real blog post and this is math bullshit.\n\nDoing all of these steps is how the *web* preview decodes the obfuscation, but that made me wonder. Could I apply these transformations without using a shader to preemptively \"fix\" the obfuscated model?\n\nAnd so I did exactly that.\n\n## the end\nThere is a wonderful utility called [gltf-transform](https://gltf-transform.dev/) written in JavaScript that seemed perfect for my use-case. Copying a small bit of the web source code, including the pseudo-rng machine, yielded good results. I was able to replicate each step up to generating the meta texture.\n\nInstead of appending a shader, I automatically went over each node and displaced the vertices. Doing this results in a VRM that is virtually indistinguishable from an obfuscated one.\n\nAfter doing the transforms statically, finally, we have Miku in all her beauty:\n\u003Cimg src=\"/blog-images/intp-theres-miku.png\" width=\"500\">\n\nOther things I needed to do (which took far longer than you'd think) were:\n- Decompressing textures, since Pixiv compresses them for web usage using BasisU which does not work in modern VRM tools.\n- Fixing the fact that `gltf-transform` deduplicates textures (this took way too long to realize)\n\nBoth of these tasks were done entirely by my friend [lith](https://xirreal.dev/) and would not be possible without her.\n\nThere is also an additional PIXIV extension I had not encountered called `PIXIV_texture_basis` which automatically encodes textures using basis encoding, but not ktx2. lith was a great help in figuring out how to decompress these.\n\nYou can find an implementation of everything discussed in a simple automation script I've released [here](https://github.com/uwu/vrh-deobfuscator).\n\n\n## further notes\nOne of my next blog posts will be an extensive deep-dive in applying similar techniques to reverse the obfuscation done by the earlier mentioned KannaProtecc, which is sufficiently more advanced but still relatively the same in terms of obfuscation.","src/content/blog/stealing intellectual property.md","27399bf76a782de7",{"html":50,"metadata":51},"\u003Cp>Recently while scrolling through Twitter I saw a post linking to a really high quality 3D model on \u003Ca href=\"https://hub.vroid.com\">VRoid Hub\u003C/a>.\u003C/p>\n\u003Cp>When you visit any VRoid Hub page, you’ll notice a large preview of the model that you can interact with, even if downloads are disabled.\u003C/p>\n\u003Cp>This got me thinking: what’s stopping someone from simply replicating the network request the website uses to fetch the contents of these private models?\u003C/p>\n\u003Cp>As it turns out? \u003Cem>A lot\u003C/em>.\u003C/p>\n\u003Ch2 id=\"what-youd-normally-do\">what you’d normally do\u003C/h2>\n\u003Cp>The first thing I did was attempt to pull up the network tab, which yielded model data basically immediately:\n\u003Cimg src=\"/blog-images/intp-network.png\" width=\"700\">\u003C/p>\n\u003Cp>I had no idea what a VRM was, but upon Googling it appeared to just be a GLB file with extensions.\u003C/p>\n\u003Cp>So, I threw the model data into a GLB viewer. It couldn’t read it.\u003C/p>\n\u003Ch2 id=\"what-vroid-hub-actually-does\">what vroid hub actually does\u003C/h2>\n\u003Cp>By using the Chrome debugger and stepping through the site’s code, I very quickly discovered that the obfuscated VRM file was encrypted with data that was present in the file itself.\u003C/p>\n\u003Cp>Each encrypted VRM is split up into 4 segments, separated by bytes:\u003C/p>\n\u003Cul>\n\u003Cli>0 through 16 are an \u003Ccode>iv\u003C/code> for decryption\u003C/li>\n\u003Cli>16 through 48 is the decryption key itself\u003C/li>\n\u003Cli>48 through 52 is the size of the decompressed version of the file\u003C/li>\n\u003C/ul>\n\u003Cp>By just throwing these into crypto.subtle’s decrypt function using \u003Ccode>AES-CBC\u003C/code>, you can yield a perfectly good, albeit, compressed VRM file.\u003C/p>\n\u003Cp>The compression VRoid Hub uses is ZSTD, which is very easy to decompress.\u003C/p>\n\u003Cp>After decrypting using the steps above, you’d think that you’d have a fully-functional model, right?\u003C/p>\n\u003Cimg src=\"/blog-images/intp-clearly-not-hatsune-miku.png\" width=\"500\">\n\u003Cp>If this looks like the world-renowned artist Hatsune Miku to you, feel free to close the article here.\u003C/p>\n\u003Ch2 id=\"okay-wtf\">okay wtf\u003C/h2>\n\u003Cp>While discussing this with a friend, they mentioned a tool used by the VRChat community called \u003Ca href=\"https://github.com/PlagueVRC/AntiRip\">KannaProtecc\u003C/a>. KannaProtecc randomizes the vertices of a model’s mesh and uses a shader to correct their positions in real-time during gameplay. This sounded suspiciously similar to what I was seeing.\u003C/p>\n\u003Cp>Inspecting the model further, I noticed a pretty striking GLB extension mentioned nowhere on the internet: \u003Ccode>PIXIV_vroid_hub_preview_mesh\u003C/code>.\u003C/p>\n\u003Cp>Searching through the VRoid Hub website source code for this string, you’ll very quickly find an  implementation of this extension with references to a “seedmap”.\u003C/p>\n\u003Cimg src=\"/blog-images/intp-vroidhub-ext.png\">\n\u003Cp>I extracted the relevant code and started analyzing it.\u003C/p>\n\u003Ch2 id=\"how-does-this-shit-work\">how does this shit work\u003C/h2>\n\u003Cp>The obfuscation process uses a pseudo-random number generator (PRNG) that produces consistent results when given the same initial seed. The seed is derived by using a “timestamp” property on the \u003Ccode>PIXIV_vroid_hub_preview_mesh\u003C/code> extension and mapping it to a “seedmap”, which is generated from running a sha1 hash over the model’s URL. The extension generates a 256x256 “meta texture” using this PRNG. This texture contains the data needed to decode each vertex.\u003C/p>\n\u003Cp>The extension then processes each node in the model’s scene, adding a meta attribute to every primitive. This attribute is calculated by running the PRNG for each vertex, generating a number between 0 and 256, normalizing it to a range of 0 to 1, and storing it in an array. Since the PRNG is deterministic, each vertex gets the same \u003Ccode>meta\u003C/code> attribute every time the extension runs.\u003C/p>\n\u003Cp>A shader is applied to sample the meta texture using the meta attribute. It scales the RGB values of the sample by 16.0 and subtracts the result from the vertex position. The direction of the displacement depends on the sign of the transformed vertex components, causing each vertex to shift toward or away from the origin based on the texture data.\u003C/p>\n\u003Cp>This is word salad, but this is also my first real blog post and this is math bullshit.\u003C/p>\n\u003Cp>Doing all of these steps is how the \u003Cem>web\u003C/em> preview decodes the obfuscation, but that made me wonder. Could I apply these transformations without using a shader to preemptively “fix” the obfuscated model?\u003C/p>\n\u003Cp>And so I did exactly that.\u003C/p>\n\u003Ch2 id=\"the-end\">the end\u003C/h2>\n\u003Cp>There is a wonderful utility called \u003Ca href=\"https://gltf-transform.dev/\">gltf-transform\u003C/a> written in JavaScript that seemed perfect for my use-case. Copying a small bit of the web source code, including the pseudo-rng machine, yielded good results. I was able to replicate each step up to generating the meta texture.\u003C/p>\n\u003Cp>Instead of appending a shader, I automatically went over each node and displaced the vertices. Doing this results in a VRM that is virtually indistinguishable from an obfuscated one.\u003C/p>\n\u003Cp>After doing the transforms statically, finally, we have Miku in all her beauty:\n\u003Cimg src=\"/blog-images/intp-theres-miku.png\" width=\"500\">\u003C/p>\n\u003Cp>Other things I needed to do (which took far longer than you’d think) were:\u003C/p>\n\u003Cul>\n\u003Cli>Decompressing textures, since Pixiv compresses them for web usage using BasisU which does not work in modern VRM tools.\u003C/li>\n\u003Cli>Fixing the fact that \u003Ccode>gltf-transform\u003C/code> deduplicates textures (this took way too long to realize)\u003C/li>\n\u003C/ul>\n\u003Cp>Both of these tasks were done entirely by my friend \u003Ca href=\"https://xirreal.dev/\">lith\u003C/a> and would not be possible without her.\u003C/p>\n\u003Cp>There is also an additional PIXIV extension I had not encountered called \u003Ccode>PIXIV_texture_basis\u003C/code> which automatically encodes textures using basis encoding, but not ktx2. lith was a great help in figuring out how to decompress these.\u003C/p>\n\u003Cp>You can find an implementation of everything discussed in a simple automation script I’ve released \u003Ca href=\"https://github.com/uwu/vrh-deobfuscator\">here\u003C/a>.\u003C/p>\n\u003Ch2 id=\"further-notes\">further notes\u003C/h2>\n\u003Cp>One of my next blog posts will be an extensive deep-dive in applying similar techniques to reverse the obfuscation done by the earlier mentioned KannaProtecc, which is sufficiently more advanced but still relatively the same in terms of obfuscation.\u003C/p>",{"headings":52,"localImagePaths":72,"remoteImagePaths":73,"frontmatter":43,"imagePaths":74},[53,57,60,63,66,69],{"depth":54,"slug":55,"text":56},2,"what-youd-normally-do","what you’d normally do",{"depth":54,"slug":58,"text":59},"what-vroid-hub-actually-does","what vroid hub actually does",{"depth":54,"slug":61,"text":62},"okay-wtf","okay wtf",{"depth":54,"slug":64,"text":65},"how-does-this-shit-work","how does this shit work",{"depth":54,"slug":67,"text":68},"the-end","the end",{"depth":54,"slug":70,"text":71},"further-notes","further notes",[],[],[],"stealing intellectual property.md"]